// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package postgresql

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const getAllOrders = `-- name: GetAllOrders :many
SELECT id, user_id, order_number, status, total_price, quantity, payment_method, shipping_fee, shipping_address, ordered_at, paid_at, memo FROM orders.order
`

func (q *Queries) GetAllOrders(ctx context.Context) ([]OrdersOrder, error) {
	rows, err := q.db.QueryContext(ctx, getAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrdersOrder
	for rows.Next() {
		var i OrdersOrder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrderNumber,
			&i.Status,
			&i.TotalPrice,
			&i.Quantity,
			&i.PaymentMethod,
			&i.ShippingFee,
			&i.ShippingAddress,
			&i.OrderedAt,
			&i.PaidAt,
			&i.Memo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderItems = `-- name: GetOrderItems :many
SELECT id, order_id, product_id, product_name, product_price, product_options, quantity FROM orders.order_items WHERE order_id = $1
`

func (q *Queries) GetOrderItems(ctx context.Context, orderID uuid.UUID) ([]OrdersOrderItem, error) {
	rows, err := q.db.QueryContext(ctx, getOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrdersOrderItem
	for rows.Next() {
		var i OrdersOrderItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ProductID,
			&i.ProductName,
			&i.ProductPrice,
			&i.ProductOptions,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderWithItems = `-- name: GetOrderWithItems :one
SELECT id, user_id, order_number, status, total_price, quantity, payment_method, shipping_fee, shipping_address, ordered_at, paid_at, memo FROM orders.order WHERE id = $1
`

func (q *Queries) GetOrderWithItems(ctx context.Context, id uuid.UUID) (OrdersOrder, error) {
	row := q.db.QueryRowContext(ctx, getOrderWithItems, id)
	var i OrdersOrder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OrderNumber,
		&i.Status,
		&i.TotalPrice,
		&i.Quantity,
		&i.PaymentMethod,
		&i.ShippingFee,
		&i.ShippingAddress,
		&i.OrderedAt,
		&i.PaidAt,
		&i.Memo,
	)
	return i, err
}

const getProductIDsByOrderID = `-- name: GetProductIDsByOrderID :many
SELECT product_id
FROM orders.order_items
WHERE order_id = $1
`

func (q *Queries) GetProductIDsByOrderID(ctx context.Context, orderID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getProductIDsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var product_id uuid.UUID
		if err := rows.Scan(&product_id); err != nil {
			return nil, err
		}
		items = append(items, product_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrder = `-- name: InsertOrder :one
INSERT INTO orders.order (
    id, user_id, order_number, status, total_price, quantity, payment_method, shipping_fee, shipping_address, ordered_at, paid_at, memo
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, COALESCE($10, CURRENT_TIMESTAMP), $11, $12
) RETURNING id
`

type InsertOrderParams struct {
	ID              uuid.UUID      `json:"id"`
	UserID          uuid.UUID      `json:"user_id"`
	OrderNumber     string         `json:"order_number"`
	Status          string         `json:"status"`
	TotalPrice      int64          `json:"total_price"`
	Quantity        int32          `json:"quantity"`
	PaymentMethod   string         `json:"payment_method"`
	ShippingFee     int32          `json:"shipping_fee"`
	ShippingAddress string         `json:"shipping_address"`
	Column10        interface{}    `json:"column_10"`
	PaidAt          sql.NullTime   `json:"paid_at"`
	Memo            sql.NullString `json:"memo"`
}

func (q *Queries) InsertOrder(ctx context.Context, arg InsertOrderParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertOrder,
		arg.ID,
		arg.UserID,
		arg.OrderNumber,
		arg.Status,
		arg.TotalPrice,
		arg.Quantity,
		arg.PaymentMethod,
		arg.ShippingFee,
		arg.ShippingAddress,
		arg.Column10,
		arg.PaidAt,
		arg.Memo,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertOrderItem = `-- name: InsertOrderItem :exec
INSERT INTO orders.order_items (
    id, order_id, product_id, product_name, product_price, product_options, quantity
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type InsertOrderItemParams struct {
	ID             uuid.UUID             `json:"id"`
	OrderID        uuid.UUID             `json:"order_id"`
	ProductID      uuid.UUID             `json:"product_id"`
	ProductName    string                `json:"product_name"`
	ProductPrice   int64                 `json:"product_price"`
	ProductOptions pqtype.NullRawMessage `json:"product_options"`
	Quantity       int32                 `json:"quantity"`
}

func (q *Queries) InsertOrderItem(ctx context.Context, arg InsertOrderItemParams) error {
	_, err := q.db.ExecContext(ctx, insertOrderItem,
		arg.ID,
		arg.OrderID,
		arg.ProductID,
		arg.ProductName,
		arg.ProductPrice,
		arg.ProductOptions,
		arg.Quantity,
	)
	return err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
UPDATE orders.order
SET status = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateOrderStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateOrderStatus, arg.ID, arg.Status)
	return err
}
